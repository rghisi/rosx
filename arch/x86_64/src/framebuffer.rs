use core::fmt;
use core::fmt::Write;
use core::sync::atomic::{AtomicU64, AtomicU8, AtomicUsize, Ordering::Relaxed};
use bootloader_api::info::{FrameBufferInfo, PixelFormat};
use kernel::default_output::KernelOutput;
use lazy_static::lazy_static;
use spin::Mutex;
use crate::ansi_parser::{AnsiColor, AnsiCommand, AnsiParser};

static FB_START:  AtomicU64   = AtomicU64::new(0);
static FB_WIDTH:  AtomicUsize = AtomicUsize::new(0);
static FB_HEIGHT: AtomicUsize = AtomicUsize::new(0);
static FB_STRIDE: AtomicUsize = AtomicUsize::new(0);
static FB_BPP:    AtomicUsize = AtomicUsize::new(4);
static FB_FMT:    AtomicU8    = AtomicU8::new(0); // 0 = RGB, 1 = BGR

const CHAR_W: usize = 8;
const CHAR_H: usize = 8;

pub fn init(buffer_start: u64, info: FrameBufferInfo) {
    FB_START.store(buffer_start, Relaxed);
    FB_WIDTH.store(info.width, Relaxed);
    FB_HEIGHT.store(info.height, Relaxed);
    FB_STRIDE.store(info.stride, Relaxed);
    FB_BPP.store(info.bytes_per_pixel, Relaxed);
    FB_FMT.store(match info.pixel_format {
        PixelFormat::Bgr => 1,
        _ => 0,
    }, Relaxed);
}

// Public-domain IBM PC 8x8 bitmap font for printable ASCII (0x20â€“0x7E).
// Each entry is 8 bytes: one byte per pixel row, MSB = leftmost pixel.
#[rustfmt::skip]
const FONT_8X8: [[u8; 8]; 95] = [
    [0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00], // 0x20 ' '
    [0x18,0x3C,0x3C,0x18,0x18,0x00,0x18,0x00], // 0x21 '!'
    [0x36,0x36,0x00,0x00,0x00,0x00,0x00,0x00], // 0x22 '"'
    [0x36,0x36,0x7F,0x36,0x7F,0x36,0x36,0x00], // 0x23 '#'
    [0x0C,0x3E,0x03,0x1E,0x30,0x1F,0x0C,0x00], // 0x24 '$'
    [0x00,0x63,0x33,0x18,0x0C,0x66,0x63,0x00], // 0x25 '%'
    [0x1C,0x36,0x1C,0x6E,0x3B,0x33,0x6E,0x00], // 0x26 '&'
    [0x06,0x06,0x03,0x00,0x00,0x00,0x00,0x00], // 0x27 '\''
    [0x18,0x0C,0x06,0x06,0x06,0x0C,0x18,0x00], // 0x28 '('
    [0x06,0x0C,0x18,0x18,0x18,0x0C,0x06,0x00], // 0x29 ')'
    [0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00], // 0x2A '*'
    [0x00,0x0C,0x0C,0x3F,0x0C,0x0C,0x00,0x00], // 0x2B '+'
    [0x00,0x00,0x00,0x00,0x00,0x0C,0x0C,0x06], // 0x2C ','
    [0x00,0x00,0x00,0x3F,0x00,0x00,0x00,0x00], // 0x2D '-'
    [0x00,0x00,0x00,0x00,0x00,0x0C,0x0C,0x00], // 0x2E '.'
    [0x60,0x30,0x18,0x0C,0x06,0x03,0x01,0x00], // 0x2F '/'
    [0x3E,0x63,0x73,0x7B,0x6F,0x67,0x3E,0x00], // 0x30 '0'
    [0x0C,0x0E,0x0C,0x0C,0x0C,0x0C,0x3F,0x00], // 0x31 '1'
    [0x1E,0x33,0x30,0x1C,0x06,0x33,0x3F,0x00], // 0x32 '2'
    [0x1E,0x33,0x30,0x1C,0x30,0x33,0x1E,0x00], // 0x33 '3'
    [0x38,0x3C,0x36,0x33,0x7F,0x30,0x78,0x00], // 0x34 '4'
    [0x3F,0x03,0x1F,0x30,0x30,0x33,0x1E,0x00], // 0x35 '5'
    [0x1C,0x06,0x03,0x1F,0x33,0x33,0x1E,0x00], // 0x36 '6'
    [0x3F,0x33,0x30,0x18,0x0C,0x0C,0x0C,0x00], // 0x37 '7'
    [0x1E,0x33,0x33,0x1E,0x33,0x33,0x1E,0x00], // 0x38 '8'
    [0x1E,0x33,0x33,0x3E,0x30,0x18,0x0E,0x00], // 0x39 '9'
    [0x00,0x0C,0x0C,0x00,0x00,0x0C,0x0C,0x00], // 0x3A ':'
    [0x00,0x0C,0x0C,0x00,0x00,0x0C,0x0C,0x06], // 0x3B ';'
    [0x18,0x0C,0x06,0x03,0x06,0x0C,0x18,0x00], // 0x3C '<'
    [0x00,0x00,0x3F,0x00,0x00,0x3F,0x00,0x00], // 0x3D '='
    [0x06,0x0C,0x18,0x30,0x18,0x0C,0x06,0x00], // 0x3E '>'
    [0x1E,0x33,0x30,0x18,0x0C,0x00,0x0C,0x00], // 0x3F '?'
    [0x3E,0x63,0x7B,0x7B,0x7B,0x03,0x1E,0x00], // 0x40 '@'
    [0x0C,0x1E,0x33,0x33,0x3F,0x33,0x33,0x00], // 0x41 'A'
    [0x3F,0x66,0x66,0x3E,0x66,0x66,0x3F,0x00], // 0x42 'B'
    [0x3C,0x66,0x03,0x03,0x03,0x66,0x3C,0x00], // 0x43 'C'
    [0x1F,0x36,0x66,0x66,0x66,0x36,0x1F,0x00], // 0x44 'D'
    [0x7F,0x46,0x16,0x1E,0x16,0x46,0x7F,0x00], // 0x45 'E'
    [0x7F,0x46,0x16,0x1E,0x16,0x06,0x0F,0x00], // 0x46 'F'
    [0x3C,0x66,0x03,0x03,0x73,0x66,0x7C,0x00], // 0x47 'G'
    [0x33,0x33,0x33,0x3F,0x33,0x33,0x33,0x00], // 0x48 'H'
    [0x1E,0x0C,0x0C,0x0C,0x0C,0x0C,0x1E,0x00], // 0x49 'I'
    [0x78,0x30,0x30,0x30,0x33,0x33,0x1E,0x00], // 0x4A 'J'
    [0x67,0x66,0x36,0x1E,0x36,0x66,0x67,0x00], // 0x4B 'K'
    [0x0F,0x06,0x06,0x06,0x46,0x66,0x7F,0x00], // 0x4C 'L'
    [0x63,0x77,0x7F,0x7F,0x6B,0x63,0x63,0x00], // 0x4D 'M'
    [0x63,0x67,0x6F,0x7B,0x73,0x63,0x63,0x00], // 0x4E 'N'
    [0x1C,0x36,0x63,0x63,0x63,0x36,0x1C,0x00], // 0x4F 'O'
    [0x3F,0x66,0x66,0x3E,0x06,0x06,0x0F,0x00], // 0x50 'P'
    [0x1E,0x33,0x33,0x33,0x3B,0x1E,0x38,0x00], // 0x51 'Q'
    [0x3F,0x66,0x66,0x3E,0x36,0x66,0x67,0x00], // 0x52 'R'
    [0x1E,0x33,0x07,0x0E,0x38,0x33,0x1E,0x00], // 0x53 'S'
    [0x3F,0x2D,0x0C,0x0C,0x0C,0x0C,0x1E,0x00], // 0x54 'T'
    [0x33,0x33,0x33,0x33,0x33,0x33,0x3F,0x00], // 0x55 'U'
    [0x33,0x33,0x33,0x33,0x33,0x1E,0x0C,0x00], // 0x56 'V'
    [0x63,0x63,0x63,0x6B,0x7F,0x77,0x63,0x00], // 0x57 'W'
    [0x63,0x63,0x36,0x1C,0x1C,0x36,0x63,0x00], // 0x58 'X'
    [0x33,0x33,0x33,0x1E,0x0C,0x0C,0x1E,0x00], // 0x59 'Y'
    [0x7F,0x63,0x31,0x18,0x4C,0x66,0x7F,0x00], // 0x5A 'Z'
    [0x1E,0x06,0x06,0x06,0x06,0x06,0x1E,0x00], // 0x5B '['
    [0x03,0x06,0x0C,0x18,0x30,0x60,0x40,0x00], // 0x5C '\'
    [0x1E,0x18,0x18,0x18,0x18,0x18,0x1E,0x00], // 0x5D ']'
    [0x08,0x1C,0x36,0x63,0x00,0x00,0x00,0x00], // 0x5E '^'
    [0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF], // 0x5F '_'
    [0x0C,0x0C,0x18,0x00,0x00,0x00,0x00,0x00], // 0x60 '`'
    [0x00,0x00,0x1E,0x30,0x3E,0x33,0x6E,0x00], // 0x61 'a'
    [0x07,0x06,0x06,0x3E,0x66,0x66,0x3B,0x00], // 0x62 'b'
    [0x00,0x00,0x1E,0x33,0x03,0x33,0x1E,0x00], // 0x63 'c'
    [0x38,0x30,0x30,0x3E,0x33,0x33,0x6E,0x00], // 0x64 'd'
    [0x00,0x00,0x1E,0x33,0x3F,0x03,0x1E,0x00], // 0x65 'e'
    [0x1C,0x36,0x06,0x0F,0x06,0x06,0x0F,0x00], // 0x66 'f'
    [0x00,0x00,0x6E,0x33,0x33,0x3E,0x30,0x1F], // 0x67 'g'
    [0x07,0x06,0x36,0x6E,0x66,0x66,0x67,0x00], // 0x68 'h'
    [0x0C,0x00,0x0E,0x0C,0x0C,0x0C,0x1E,0x00], // 0x69 'i'
    [0x30,0x00,0x30,0x30,0x30,0x33,0x33,0x1E], // 0x6A 'j'
    [0x07,0x06,0x66,0x36,0x1E,0x36,0x67,0x00], // 0x6B 'k'
    [0x0E,0x0C,0x0C,0x0C,0x0C,0x0C,0x1E,0x00], // 0x6C 'l'
    [0x00,0x00,0x33,0x7F,0x7F,0x6B,0x63,0x00], // 0x6D 'm'
    [0x00,0x00,0x1F,0x33,0x33,0x33,0x33,0x00], // 0x6E 'n'
    [0x00,0x00,0x1E,0x33,0x33,0x33,0x1E,0x00], // 0x6F 'o'
    [0x00,0x00,0x3B,0x66,0x66,0x3E,0x06,0x0F], // 0x70 'p'
    [0x00,0x00,0x6E,0x33,0x33,0x3E,0x30,0x78], // 0x71 'q'
    [0x00,0x00,0x3B,0x6E,0x66,0x06,0x0F,0x00], // 0x72 'r'
    [0x00,0x00,0x3E,0x03,0x1E,0x30,0x1F,0x00], // 0x73 's'
    [0x08,0x0C,0x3E,0x0C,0x0C,0x2C,0x18,0x00], // 0x74 't'
    [0x00,0x00,0x33,0x33,0x33,0x33,0x6E,0x00], // 0x75 'u'
    [0x00,0x00,0x33,0x33,0x33,0x1E,0x0C,0x00], // 0x76 'v'
    [0x00,0x00,0x63,0x6B,0x7F,0x7F,0x36,0x00], // 0x77 'w'
    [0x00,0x00,0x63,0x36,0x1C,0x36,0x63,0x00], // 0x78 'x'
    [0x00,0x00,0x33,0x33,0x33,0x3E,0x30,0x1F], // 0x79 'y'
    [0x00,0x00,0x3F,0x19,0x0C,0x26,0x3F,0x00], // 0x7A 'z'
    [0x38,0x0C,0x0C,0x07,0x0C,0x0C,0x38,0x00], // 0x7B '{'
    [0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x00], // 0x7C '|'
    [0x07,0x0C,0x0C,0x38,0x0C,0x0C,0x07,0x00], // 0x7D '}'
    [0x6E,0x3B,0x00,0x00,0x00,0x00,0x00,0x00], // 0x7E '~'
];

fn draw_char(col: usize, row: usize, ch: u8, fg: (u8, u8, u8), bg: (u8, u8, u8)) {
    let start = FB_START.load(Relaxed) as *mut u8;
    if start.is_null() { return; }
    let stride = FB_STRIDE.load(Relaxed);
    let bpp    = FB_BPP.load(Relaxed);
    let fmt    = FB_FMT.load(Relaxed);
    let idx    = if ch >= 0x20 && ch <= 0x7E { (ch - 0x20) as usize } else { 0 };
    let glyph  = &FONT_8X8[idx];
    let base_x = col * CHAR_W;
    let base_y = row * CHAR_H;
    for (bit_y, &row_bits) in glyph.iter().enumerate() {
        let row_base = (base_y + bit_y) * stride * bpp;
        for bit_x in 0..CHAR_W {
            let (r, g, b) = if (row_bits >> (7 - bit_x)) & 1 != 0 { fg } else { bg };
            let off = row_base + (base_x + bit_x) * bpp;
            unsafe {
                let ptr = start.add(off);
                if fmt == 1 { ptr.write(b); ptr.add(1).write(g); ptr.add(2).write(r); }
                else         { ptr.write(r); ptr.add(1).write(g); ptr.add(2).write(b); }
            }
        }
    }
}

fn scroll_up() {
    let start  = FB_START.load(Relaxed) as *mut u8;
    if start.is_null() { return; }
    let height = FB_HEIGHT.load(Relaxed);
    let stride = FB_STRIDE.load(Relaxed);
    let bpp    = FB_BPP.load(Relaxed);
    let row_bytes    = stride * bpp;
    let scroll_bytes = CHAR_H * row_bytes;
    let total_bytes  = height * row_bytes;
    unsafe {
        core::ptr::copy(start.add(scroll_bytes), start, total_bytes - scroll_bytes);
        core::ptr::write_bytes(start.add(total_bytes - scroll_bytes), 0, scroll_bytes);
    }
}

fn ansi_to_rgb(c: AnsiColor) -> (u8, u8, u8) {
    match c {
        AnsiColor::Black         => (0,   0,   0),
        AnsiColor::Red           => (170, 0,   0),
        AnsiColor::Green         => (0,   170, 0),
        AnsiColor::Yellow        => (170, 170, 0),
        AnsiColor::Blue          => (0,   0,   170),
        AnsiColor::Magenta       => (170, 0,   170),
        AnsiColor::Cyan          => (0,   170, 170),
        AnsiColor::White         => (170, 170, 170),
        AnsiColor::BrightBlack   => (85,  85,  85),
        AnsiColor::BrightRed     => (255, 85,  85),
        AnsiColor::BrightGreen   => (85,  255, 85),
        AnsiColor::BrightYellow  => (255, 255, 85),
        AnsiColor::BrightBlue    => (85,  85,  255),
        AnsiColor::BrightMagenta => (255, 85,  255),
        AnsiColor::BrightCyan    => (85,  255, 255),
        AnsiColor::BrightWhite   => (255, 255, 255),
    }
}

struct Writer {
    col:        usize,
    row:        usize,
    text_cols:  usize,
    text_rows:  usize,
    fg:         (u8, u8, u8),
    bg:         (u8, u8, u8),
    default_fg: (u8, u8, u8),
    default_bg: (u8, u8, u8),
    ansi_parser: AnsiParser,
}

impl Writer {
    fn new() -> Self {
        let fg = (0, 255, 0);
        let bg = (0, 0, 0);
        Writer {
            col: 0,
            row: 0,
            text_cols:  FB_WIDTH.load(Relaxed)  / CHAR_W,
            text_rows:  FB_HEIGHT.load(Relaxed) / CHAR_H,
            fg,
            bg,
            default_fg: fg,
            default_bg: bg,
            ansi_parser: AnsiParser::new(),
        }
    }

    fn write_byte(&mut self, byte: u8) {
        self.ansi_parser.handle_byte(byte);
        while let Some(cmd) = self.ansi_parser.next_command() {
            match cmd {
                AnsiCommand::PrintChar(b)          => self.internal_write_byte(b),
                AnsiCommand::SetForeground(c)      => { self.fg = ansi_to_rgb(c); }
                AnsiCommand::SetBackground(c)      => { self.bg = ansi_to_rgb(c); }
                AnsiCommand::ResetAttributes       => { self.fg = self.default_fg; self.bg = self.default_bg; }
                AnsiCommand::SetCursorPos{row, col} => {
                    self.row = row.min(self.text_rows.saturating_sub(1));
                    self.col = col.min(self.text_cols.saturating_sub(1));
                }
                AnsiCommand::ClearScreen => {
                    let start = FB_START.load(Relaxed) as *mut u8;
                    if !start.is_null() {
                        let bytes = FB_HEIGHT.load(Relaxed) * FB_STRIDE.load(Relaxed) * FB_BPP.load(Relaxed);
                        unsafe { core::ptr::write_bytes(start, 0, bytes); }
                    }
                    self.row = 0;
                    self.col = 0;
                }
                AnsiCommand::ClearLine => {
                    for c in 0..self.text_cols { draw_char(c, self.row, b' ', self.fg, self.bg); }
                    self.col = 0;
                }
            }
        }
    }

    fn internal_write_byte(&mut self, byte: u8) {
        match byte {
            b'\n' => self.new_line(),
            b'\t' => {
                let next_tab = (self.col / 8 + 1) * 8;
                self.col = next_tab.min(self.text_cols);
            }
            0x08 => {
                if self.col > 0 {
                    self.col -= 1;
                    draw_char(self.col, self.row, b' ', self.fg, self.bg);
                }
            }
            byte => {
                if self.col >= self.text_cols { self.new_line(); }
                draw_char(self.col, self.row, byte, self.fg, self.bg);
                self.col += 1;
            }
        }
    }

    fn new_line(&mut self) {
        self.col = 0;
        if self.text_rows > 0 && self.row + 1 < self.text_rows {
            self.row += 1;
        } else {
            scroll_up();
        }
    }

    fn write_string(&mut self, s: &str) {
        for byte in s.bytes() {
            match byte {
                0x20..=0x7E | b'\n' | b'\t' | 0x08 | 0x1B => self.write_byte(byte),
                _ => self.write_byte(b'?'),
            }
        }
    }
}

impl fmt::Write for Writer {
    fn write_str(&mut self, s: &str) -> fmt::Result {
        self.write_string(s);
        Ok(())
    }
}

lazy_static! {
    static ref WRITER: Mutex<Writer> = Mutex::new(Writer::new());
}

pub struct FramebufferOutput;

impl KernelOutput for FramebufferOutput {
    fn write_str(&self, s: &str) {
        WRITER.lock().write_str(s).unwrap();
    }
}
